
/*
 * Firefly III API v1.5.4
 *
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2021-09-25T14:21:28+00:00 
 *
 * API version: 1.5.4
 * Contact: james@firefly-iii.org
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package ffgo

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type InsightApiService service
/*
InsightApiService Insight into expenses, grouped by asset account.
This endpoint gives a summary of the expenses made by the user, grouped by asset account. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseAssetOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseAssetOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseAsset(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseAssetOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, grouped by bill.
This endpoint gives a summary of the expenses made by the user, grouped by (any) bill. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseBillOpts - Optional Parameters:
     * @param "Bills" (optional.Interface of []int64) -  The bills to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseBillOpts struct {
    Bills optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseBill(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseBillOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/bill"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Bills.IsSet() {
		localVarQueryParams.Add("bills[]", parameterToString(localVarOptionals.Bills.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, grouped by budget.
This endpoint gives a summary of the expenses made by the user, grouped by (any) budget. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseBudgetOpts - Optional Parameters:
     * @param "Budgets" (optional.Interface of []int64) -  The budgets to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseBudgetOpts struct {
    Budgets optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseBudget(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseBudgetOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/budget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Budgets.IsSet() {
		localVarQueryParams.Add("budgets[]", parameterToString(localVarOptionals.Budgets.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, grouped by category.
This endpoint gives a summary of the expenses made by the user, grouped by (any) category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseCategoryOpts - Optional Parameters:
     * @param "Categories" (optional.Interface of []int64) -  The categories to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseCategoryOpts struct {
    Categories optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseCategoryOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("categories[]", parameterToString(localVarOptionals.Categories.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, grouped by expense account.
This endpoint gives a summary of the expenses made by the user, grouped by expense account. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseExpenseOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you add the accounts ID&#x27;s of expense accounts, only those accounts are included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. You can combine both asset / liability and expense account ID&#x27;s. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseExpenseOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseExpense(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseExpenseOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/expense"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, without bill.
This endpoint gives a summary of the expenses made by the user, including only expenses with no bill. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseNoBillOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightExpenseNoBillOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseNoBill(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseNoBillOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/no-bill"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, without budget.
This endpoint gives a summary of the expenses made by the user, including only expenses with no budget. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseNoBudgetOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightExpenseNoBudgetOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseNoBudget(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseNoBudgetOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/no-budget"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, without category.
This endpoint gives a summary of the expenses made by the user, including only expenses with no category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseNoCategoryOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightExpenseNoCategoryOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseNoCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseNoCategoryOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, without tag.
This endpoint gives a summary of the expenses made by the user, including only expenses with no tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseNoTagOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightExpenseNoTagOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseNoTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseNoTagOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, grouped by tag.
This endpoint gives a summary of the expenses made by the user, grouped by (any) tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseTagOpts - Optional Parameters:
     * @param "Tags" (optional.Interface of []int64) -  The tags to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightExpenseTagOpts struct {
    Tags optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseTagOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags[]", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into total expenses.
This endpoint gives a sum of the total expenses made by the user. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightExpenseTotalOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only withdrawals from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightExpenseTotalOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightExpenseTotal(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightExpenseTotalOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/expense/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, grouped by asset account.
This endpoint gives a summary of the income received by the user, grouped by asset account. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeAssetOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightIncomeAssetOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeAsset(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeAssetOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, grouped by category.
This endpoint gives a summary of the income received by the user, grouped by (any) category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeCategoryOpts - Optional Parameters:
     * @param "Categories" (optional.Interface of []int64) -  The categories to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightIncomeCategoryOpts struct {
    Categories optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeCategoryOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("categories[]", parameterToString(localVarOptionals.Categories.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, without category.
This endpoint gives a summary of the income received by the user, including only income with no category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeNoCategoryOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightIncomeNoCategoryOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeNoCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeNoCategoryOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, without tag.
This endpoint gives a summary of the income received by the user, including only income with no tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeNoTagOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightIncomeNoTagOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeNoTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeNoTagOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, grouped by revenue account.
This endpoint gives a summary of the income received by the user, grouped by revenue account. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeRevenueOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you add the accounts ID&#x27;s of revenue accounts, only those accounts are included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. You can combine both asset / liability and deposit account ID&#x27;s. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightIncomeRevenueOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeRevenue(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeRevenueOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/revenue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into income, grouped by tag.
This endpoint gives a summary of the income received by the user, grouped by (any) tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeTagOpts - Optional Parameters:
     * @param "Tags" (optional.Interface of []int64) -  The tags to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightIncomeTagOpts struct {
    Tags optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeTagOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags[]", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into total income.
This endpoint gives a sum of the total income received by the user. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightIncomeTotalOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only deposits to those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightIncomeTotalOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightIncomeTotal(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightIncomeTotalOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/income/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into transfers, grouped by category.
This endpoint gives a summary of the transfers made by the user, grouped by (any) category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransferCategoryOpts - Optional Parameters:
     * @param "Categories" (optional.Interface of []int64) -  The categories to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightTransferCategoryOpts struct {
    Categories optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransferCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransferCategoryOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("categories[]", parameterToString(localVarOptionals.Categories.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into transfers, without category.
This endpoint gives a summary of the transfers made by the user, including only transfers with no category. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransferNoCategoryOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightTransferNoCategoryOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransferNoCategory(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransferNoCategoryOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/no-category"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into expenses, without tag.
This endpoint gives a summary of the transfers made by the user, including only transfers with no tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransferNoTagOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers from those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightTransferNoTagOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransferNoTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransferNoTagOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/no-tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into transfers, grouped by tag.
This endpoint gives a summary of the transfers created by the user, grouped by (any) tag. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransferTagOpts - Optional Parameters:
     * @param "Tags" (optional.Interface of []int64) -  The tags to be included in the results. 
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightGroupEntry
*/

type InsightApiInsightTransferTagOpts struct {
    Tags optional.Interface
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransferTag(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransferTagOpts) ([]InsightGroupEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightGroupEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags[]", parameterToString(localVarOptionals.Tags.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightGroupEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into total transfers.
This endpoint gives a sum of the total amount transfers made by the user. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransferTotalOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTotalEntry
*/

type InsightApiInsightTransferTotalOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransferTotal(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransferTotalOpts) ([]InsightTotalEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTotalEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTotalEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
InsightApiService Insight into transfers, grouped by account.
This endpoint gives a summary of the transfers made by the user, grouped by asset account or lability. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param start A date formatted YYYY-MM-DD. 
 * @param end A date formatted YYYY-MM-DD. 
 * @param optional nil or *InsightApiInsightTransfersOpts - Optional Parameters:
     * @param "Accounts" (optional.Interface of []int64) -  The accounts to be included in the results. If you include ID&#x27;s of asset accounts or liabilities, only transfers between those asset accounts / liabilities will be included. Other account ID&#x27;s will be ignored. 
@return []InsightTransferEntry
*/

type InsightApiInsightTransfersOpts struct {
    Accounts optional.Interface
}

func (a *InsightApiService) InsightTransfers(ctx context.Context, start string, end string, localVarOptionals *InsightApiInsightTransfersOpts) ([]InsightTransferEntry, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InsightTransferEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/insight/transfer/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("start", parameterToString(start, ""))
	localVarQueryParams.Add("end", parameterToString(end, ""))
	if localVarOptionals != nil && localVarOptionals.Accounts.IsSet() {
		localVarQueryParams.Add("accounts[]", parameterToString(localVarOptionals.Accounts.Value(), "multi"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []InsightTransferEntry
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
